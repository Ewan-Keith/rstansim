---
title: "Using rstansim to run a simulation study"
author: "Ewan Keith"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using rstansim}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r,echo=FALSE,results='asis'}
knitr::opts_chunk$set(collapse = T)
```

## Introduction

This document gives an end to end example of using the rstansim package to carry out a small simulation study using stan. Itâ€™s recommended as a first point of call to understand how the package works, but does not provided detailed documentation of all functionality. 

After reading through this example, the below documents can provide further detailed documentation on specific elements:

* Simulating data using rstansim. [ADD LINK]
* Fitting models using rstansim. [ADD LINK]
* Managing results using rstansim. [ADD LINK]

Beyond that function documentation can be found here. [ADD LINK]

### The study question

Any simulation study needs to start with a question about the behaviour of certain models/estimators under specific conditions. In this case, our question comes straight from the stan manual.

In the section on regression models, the first example of a multiple regression model in stan is a straightforward vectorised implementation, shown below.

```{R, engine = 'cat', engine.opts = list(file = "simple_reg_model.stan", lang = "stan")}
// saved as simple_reg_model.stan
data {
  int<lower=0> N; // number of data items
  int<lower=0> K; // number of predictors
  matrix[N, K] x; // predictor matrix
  vector[N] y; // outcome vector
}
parameters {
  real alpha; // intercept
  vector[K] beta; // coefficients for predictors
  real<lower=0> sigma; // error scale
}
model {
  y ~ normal(x * beta + alpha, sigma); // likelihood
}
```

However immediately after this is introduced another way to format a multiple regression, named the QR Reparameterization, is introduced. Again this is shown below.

```{R, engine = 'cat', engine.opts = list(file = "qr_reg_model.stan", lang = "stan")}
// saved as qr_reg_model.stan
data {
  int<lower=0> N; // number of data items
  int<lower=0> K; // number of predictors
}
transformed data {
  matrix[N, K] Q_ast;
  matrix[K, K] R_ast;
  matrix[K, K] R_ast_inverse;
  // thin and scale the QR decomposition
  Q_ast = qr_Q(x)[, 1:K] * sqrt(N - 1);
  R_ast = qr_R(x)[1:K, ] / sqrt(N - 1);
  R_ast_inverse = inverse(R_ast);
}
parameters {
  real alpha; // intercept
  vector[K] theta; // coefficients on Q_ast
  real<lower=0> sigma; // error scale
}
model {
  y ~ normal(Q_ast * theta + alpha, sigma); // likelihood
}
generated quantities {
  vector[K] beta;
  beta = R_ast_inverse * theta; // coefficients on x
}
```

The stan manual provides more detail on the derivation of the QR parameterization, and the reasons for it's efficiency. In short the reasons given to use the QR model are that it:

1. Gives equivalent posterior parameter estimates to the original model
2. Can decrease the total elapsed time to fit a model.
2. Can improve the effective sample size (ESS) for sampled parameter chains.

This small simulation study will explore the above three advantages to see if they hold for the simulated data, and to assess the magnitude of any observed differences between the two models. 

## Simulating the data

In order to test our above hypotheses we'll be simulating data two generative models. The models only differ in their parameter values and so can both be simulaetd using a single stan model (if there were structural differences then they would require different models). 

One of the advantages of using rstansim to generate data for a simulation study is that it lets you use a stan model to specify the data, this gives you a huge degree of flexibility in how the simulated data will look, and can even let you draw your posterior samples using the same code that generated your data. For clarity here though we've generated a small stan model purely for the purposes of generating our simulated data, it's shown below.

```{R, engine = 'cat', engine.opts = list(file = "sim_data_model.stan", lang = "stan")}
// saved as sim_data_model.stan
data {
  int<lower=0> N; // number of data items
  int<lower=0> K; // number of predictors
}
parameters {
  real alpha; // intercept
  vector[K] beta; // coefficients for predictors
  real<lower=0> sigma; // error scale
  corr_matrix[K] omega;
}
transformed parameters{
  cov_matrix[K] cov_omega;

  cov_omega = quad_form_diag(omega, rep_vector(1, K));
}
generated quantities {
  matrix[N, K] sim_x; // simulated predictor data
  vector[N] sim_y; // simulated outcome vector

  for(i in 1:N) sim_x[i,] = multi_normal_rng(rep_vector(0, K), cov_omega)';
  for(i in 1:N) sim_y[i] = normal_rng(alpha + sim_x[i] * beta, sigma)';
}
```

This model is cut down to only be used for simulating the desired data. The important points to note are:

1. Any data or parameters that you wish to vary in order to produce different simulated datasets are entered in the `data` or `parameter` blocks, as with a typical stan model.
2. All variables to be simulated are specified in the `generated quantities` block, using stan's built in random number generators.
3. Note that the simulated variables have their names prepended with `sim_`, this is good practice to differentiate simulated quantities in the model from user provided values. By default this `sim_` will be dropped from the saved dataset so that the data can easily be used as model input (e.g. `sim_x` becomes just `x`).

The `simulate_data()` function can take this model, along with data and parameter values to use, and use them to simulate multiple datasets containing the relevant data. When called `simulate_data()` has two effects; it saves all simulated datasets to a specified directory, and it returns an object of class `stansim_data` which acts as a 'ticket' for the saved datasets; providing summary information and able to be fed directly in to the `fit_models()` function below, simplifying the workflow.

For the purposes of our simulation we want to simulate 100 datasets, 50 of which will have uncorrelated `x` columns, and 50 of which will have correlations varying between 0 and 0.4. It's expected that the benefits of the QR model will be greater for the correlated predictors datasets. The input data and parameters for these are specified below.

```{R}
# set up independent covariance matrix
omega_uncorr <- diag(5)
omega_uncorr

# set up correlated covariance matrix
omega_corr <- matrix(rbind(c(1, 0, .2, .3, .4),
                           c(0, 1, .3, .4, .2),
                           c(.2, .3, 1, 0, .4), 
                           c(.3, .4, 0, 1, .2), 
                           c(.4, .2, .4, .2, 1)), 5, 5)
omega_corr

regression_input_data <- list("N" = 1000, "K" = 5)

regression_uncorr_params <- list("alpha" = 5, "beta" = c(0, 0, .8, .6, .4),
                                 "sigma" = 1, "omega" = omega_uncorr)

regression_corr_params <-list("alpha" = 5, "beta" = c(0, 0, .8, .6, .4),
                              "sigma" = 1, "omega" = omega_corr)

```

With our input values set up we can now simulate data easily.

```{R, results = "hide", message = F, warning = F}
library(rstansim)

# simulate data with uncorrelated predictors
uncorrelated_data <- simulate_data(
  file = "sim_data_model.stan",
  data_name = "uncorrelated multi-regression",
  input_data = regression_input_data,
  param_values = regression_uncorr_params,
  vars = c("N", "K", "sim_x", "sim_y"),
  nsim = 50,
  path = "reg_data/uncorrelated"
  )

# simulate data with correlated predictors
correlated_data <- simulate_data(
  file = "sim_data_model.stan",
  data_name = "correlated multi-regression",
  input_data = regression_input_data,
  param_values = regression_corr_params, 
  vars = c("N", "K", "sim_x", "sim_y"),
  nsim = 50,
  path = "reg_data/correlated"
  )

```

Looking in our working directory shows that the specified folders have been created and filled with our simulated datasets.

```{R}
# see folders inside reg_data/
dir("reg_data")

# see first five files in reg_data/correlated/
dir("reg_data/correlated")[1:5]

```

For a quick check that things have run as expected we'll take a look at a given simuldated data file.

```{R}
str(readRDS("reg_data/correlated/correlated multi-regression_1.rds"))

```

## Fitting the models

## Collecting the results

## Analysing results

```{r,echo=FALSE,results='asis'}
## clean up all created files from vignetes/
# remove stan models
if(file.exists("simple_reg_model.stan"))
  unlink("simple_reg_model.stan")

if(file.exists("qr_reg_model.stan"))
  unlink("qr_reg_model.stan")

if(file.exists("sim_data_model.stan"))
  unlink("sim_data_model.stan")

# if simulated data dir has been created, delete it
if(dir.exists("reg_data"))
  unlink("reg_data", recursive = T)
```
